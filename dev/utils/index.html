<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities · AutoEncoderToolkit</title><meta name="title" content="Utilities · AutoEncoderToolkit"/><meta property="og:title" content="Utilities · AutoEncoderToolkit"/><meta property="twitter:title" content="Utilities · AutoEncoderToolkit"/><meta name="description" content="Documentation for AutoEncoderToolkit."/><meta property="og:description" content="Documentation for AutoEncoderToolkit."/><meta property="twitter:description" content="Documentation for AutoEncoderToolkit."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="AutoEncoderToolkit logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="AutoEncoderToolkit logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AutoEncoderToolkit</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../encoders/">Encoders &amp; Decoders</a></li><li><a class="tocitem" href="../layers/">Custom Layers</a></li><li><a class="tocitem" href="../ae/">Deterministic Autoencoders</a></li><li><a class="tocitem" href="../vae/">VAE / β-VAE</a></li><li><a class="tocitem" href="../mmdvae/">MMD-VAE (InfoVAE)</a></li><li><a class="tocitem" href="../infomaxvae/">InfoMax-VAE</a></li><li><a class="tocitem" href="../hvae/">HVAE</a></li><li><a class="tocitem" href="../rhvae/">RHVAE</a></li><li><a class="tocitem" href="../diffgeo/">Differential Geometry</a></li><li class="is-active"><a class="tocitem" href>Utilities</a><ul class="internal"><li><a class="tocitem" href="#Training-Utilities"><span>Training Utilities</span></a></li><li><a class="tocitem" href="#centroidutils"><span>Centroid Finding Utilities</span></a></li><li><a class="tocitem" href="#Other-Utilities"><span>Other Utilities</span></a></li></ul></li><li><a class="tocitem" href="../guidelines/">Community Guidelines</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h1><p><code>AutoEncoderToolkit.jl</code> offers a series of utility functions for different tasks. </p><h2 id="Training-Utilities"><a class="docs-heading-anchor" href="#Training-Utilities">Training Utilities</a><a id="Training-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Training-Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.step_scheduler" href="#AutoEncoderToolkit.utils.step_scheduler"><code>AutoEncoderToolkit.utils.step_scheduler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`step_scheduler(epoch, epoch_change, learning_rates)`</code></pre><p>Simple function to define different learning rates at specified epochs.</p><p><strong>Arguments</strong></p><ul><li><code>epoch::Int</code>: Epoch at which to define learning rate.</li><li><code>epoch_change::Vector{&lt;:Int}</code>: Number of epochs at which to change learning rate. It must include the initial learning rate!</li><li><code>learning_rates::Vector{&lt;:AbstractFloat}</code>: Learning rate value for the epoch range. Must be the same length as <code>epoch_change</code></li></ul><p><strong>Returns</strong></p><ul><li><code>η::AbstractFloat</code>: Learning rate for the current epoch.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.cycle_anneal" href="#AutoEncoderToolkit.utils.cycle_anneal"><code>AutoEncoderToolkit.utils.cycle_anneal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cycle_anneal(
    epoch::Int, 
    n_epoch::Int, 
    n_cycles::Int; 
    frac::AbstractFloat=0.5f0, 
    βmax::Number=1.0f0, 
    βmin::Number=0.0f0, 
    T::Type=Float32
)</code></pre><p>Function that computes the value of the annealing parameter β for a variational autoencoder as a function of the epoch number according to the cyclical annealing strategy.</p><p><strong>Arguments</strong></p><ul><li><code>epoch::Int</code>: Epoch on which to evaluate the value of the annealing parameter.</li><li><code>n_epoch::Int</code>: Number of epochs that will be run to train the VAE.</li><li><code>n_cycles::Int</code>: Number of annealing cycles to be fit within the number of epochs.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>frac::AbstractFloat= 0.5f0</code>: Fraction of the cycle in which the annealing parameter β will increase from the minimum to the maximum value.</li><li><code>βmax::Number=1.0f0</code>: Maximum value that the annealing parameter can reach.</li><li><code>βmin::Number=0.0f0</code>: Minimum value that the annealing parameter can reach.</li><li><code>T::Type=Float32</code>: The type of the output. The function will convert the output to this type.</li></ul><p><strong>Returns</strong></p><ul><li><code>β::T</code>: Value of the annealing parameter.</li></ul><p><strong>Citation</strong></p><blockquote><p>Fu, H. et al. Cyclical Annealing Schedule: A Simple Approach to Mitigating KL Vanishing. Preprint at http://arxiv.org/abs/1903.10145 (2019).</p></blockquote></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.locality_sampler" href="#AutoEncoderToolkit.utils.locality_sampler"><code>AutoEncoderToolkit.utils.locality_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>locality_sampler(data, dist_tree, n_primary, n_secondary, k_neighbors; index=false)</code></p><p>Algorithm to generate mini-batches based on spatial locality as determined by a pre-constructed nearest neighbors tree.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray</code>: An array containing the data points. The data points can be of any dimension.</li><li><code>dist_tree::NearestNeighbors.NNTree</code>: <code>NearestNeighbors.jl</code> tree used to determine the distance between data points.</li><li><code>n_primary::Int</code>: Number of primary points to sample.</li><li><code>n_secondary::Int</code>: Number of secondary points to sample from the neighbors of each primary point.</li><li><code>k_neighbors::Int</code>: Number of nearest neighbors from which to potentially sample the secondary points.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>index::Bool</code>: If <code>true</code>, returns the indices of the selected samples. If <code>false</code>, returns the <code>data</code> corresponding to the indexes. Defaults to <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>index</code> is <code>true</code>, returns <code>sample_idx::Vector{Int64}</code>: Indices of data points to include in the mini-batch.</li><li>If <code>index</code> is <code>false</code>, returns <code>sample_data::AbstractArray</code>: The data points to include in the mini-batch.</li></ul><p><strong>Description</strong></p><p>This sampling algorithm consists of three steps:</p><ol><li>For each datapoint, determine the <code>k_neighbors</code> nearest neighbors using the <code>dist_tree</code>.</li><li>Uniformly sample <code>n_primary</code> points without replacement from all data points.</li><li>For each primary point, sample <code>n_secondary</code> points without replacement from its <code>k_neighbors</code> nearest neighbors.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Pre-constructed NearestNeighbors.jl tree
dist_tree = NearestNeighbors.KDTree(data, metric)
sample_indices = locality_sampler(data, dist_tree, 10, 5, 50)</code></pre><p><strong>Citation</strong></p><blockquote><p>Skafte, N., Jø rgensen, M. &amp; Hauberg, S. ren. Reliable training and estimation of variance networks. in Advances in Neural Information Processing Systems vol. 32 (Curran Associates, Inc., 2019).</p></blockquote></div></section></article><h2 id="centroidutils"><a class="docs-heading-anchor" href="#centroidutils">Centroid Finding Utilities</a><a id="centroidutils-1"></a><a class="docs-heading-anchor-permalink" href="#centroidutils" title="Permalink"></a></h2><p>Some VAE models, such as the <a href="../rhvae/#RHVAEsmodule"><code>RHVAE</code></a>, require clustering of the data. Specifically <code>RHVAE</code> can take a fixed subset of the training data as a reference for the computation of the metric tensor. The following functions can be used to define this reference subset to be used as centroids for the metric tensor computation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.centroids_kmeans" href="#AutoEncoderToolkit.utils.centroids_kmeans"><code>AutoEncoderToolkit.utils.centroids_kmeans</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centroids_kmeans(
    x::AbstractMatrix, 
    n_centroids::Int; 
    assign::Bool=false
)</code></pre><p>Perform k-means clustering on the input and return the centers. This function can be used to down-sample the number of points used when computing the metric tensor in training a Riemannian Hamiltonian Variational Autoencoder (RHVAE).</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix</code>: The input data. Rows represent individual samples.</li><li><code>n_centroids::Int</code>: The number of centroids to compute.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>assign::Bool=false</code>: If true, also return the assignments of each point to a centroid.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>assign</code> is false, returns a matrix where each column is a centroid.</li><li>If <code>assign</code> is true, returns a tuple where the first element is the matrix of centroids and the second element is a vector of assignments.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = rand(100, 10)
centroids = centroids_kmeans(data, 5)</code></pre></div></section><section><div><pre><code class="language-julia hljs">centroids_kmeans(
    x::AbstractArray, 
    n_centroids::Int; 
    reshape_centroids::Bool=true, 
    assign::Bool=false
)</code></pre><p>Perform k-means clustering on the input and return the centers. This function can be used to down-sample the number of points used when computing the metric tensor in training a Riemannian Hamiltonian Variational Autoencoder (RHVAE).</p><p>The input data is flattened into a matrix before performing k-means clustering. This is done because k-means operates on a set of data points in a vector space and cannot handle multi-dimensional arrays. Flattening the input ensures that the k-means algorithm can process the data correctly.</p><p>By default, the output centroids are reshaped back to the original input shape. This is controlled by the <code>reshape_centroids</code> argument.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: The input data. It can be a multi-dimensional array where the last dimension represents individual samples.</li><li><code>n_centroids::Int</code>: The number of centroids to compute.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>reshape_centroids::Bool=true</code>: If true, reshape the output centroids back to the original input shape.</li><li><code>assign::Bool=false</code>: If true, also return the assignments of each point to a centroid.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>assign</code> is false, returns a matrix where each column is a centroid.</li><li>If <code>assign</code> is true, returns a tuple where the first element is the matrix of centroids and the second element is a vector of assignments.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = rand(100, 10)
centroids = centroids_kmeans(data, 5)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.centroids_kmedoids" href="#AutoEncoderToolkit.utils.centroids_kmedoids"><code>AutoEncoderToolkit.utils.centroids_kmedoids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    centroids_kmedoids(
        x::AbstractMatrix, n_centroids::Int; assign::Bool=false
    )</code></pre><p>Perform k-medoids clustering on the input and return the centers. This function can be used to down-sample the number of points used when computing the metric tensor in training a Riemannian Hamiltonian Variational Autoencoder (RHVAE).</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix</code>: The input data. Rows represent individual samples.</li><li><code>n_centroids::Int</code>: The number of centroids to compute.</li><li><code>dist::Distances.PreMetric=Distances.Euclidean()</code>: The distance metric to use when computing the pairwise distance matrix.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>assign::Bool=false</code>: If true, also return the assignments of each point to a centroid.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>assign</code> is false, returns a matrix where each column is a centroid.</li><li>If <code>assign</code> is true, returns a tuple where the first element is the matrix of centroids and the second element is a vector of assignments.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = rand(100, 10)
centroids = centroids_kmedoids(data, 5)</code></pre></div></section><section><div><pre><code class="language-julia hljs">centroids_kmedoids(
    x::AbstractArray,
    n_centroids::Int,
    dist::Distances.PreMetric=Distances.Euclidean();
    assign::Bool=false
)</code></pre><p>Perform k-medoids clustering on the input and return the centers. This function can be used to down-sample the number of points used when computing the metric tensor in training a Riemannian Hamiltonian Variational Autoencoder (RHVAE).</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: The input data. The last dimension of <code>x</code> should contain each of the samples that should be clustered.</li><li><code>n_centroids::Int</code>: The number of centroids to compute.</li><li><code>dist::Distances.PreMetric=Distances.Euclidean()</code>: The distance metric to use for the clustering. Defaults to Euclidean distance.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>assign::Bool=false</code>: If true, also return the assignments of each point to a centroid.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>assign</code> is false, returns an array where each column is a centroid.</li><li>If <code>assign</code> is true, returns a tuple where the first element is the array of centroids and the second element is a vector of assignments.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = rand(10, 100)
centroids = centroids_kmedoids(data, 5)</code></pre></div></section></article><h2 id="Other-Utilities"><a class="docs-heading-anchor" href="#Other-Utilities">Other Utilities</a><a id="Other-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.storage_type" href="#AutoEncoderToolkit.utils.storage_type"><code>AutoEncoderToolkit.utils.storage_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">storage_type(A::AbstractArray)</code></pre><p>Determine the storage type of an array.</p><p>This function recursively checks the parent of the array until it finds the base storage type. This is useful for determining whether an array or its subarrays are stored on the CPU or GPU.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The array whose storage type is to be determined.</li></ul><p><strong>Returns</strong></p><p>The type of the array that is the base storage of <code>A</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.vec_to_ltri" href="#AutoEncoderToolkit.utils.vec_to_ltri"><code>AutoEncoderToolkit.utils.vec_to_ltri</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    vec_to_ltri(diag::AbstractVecOrMat, lower::AbstractVecOrMat)</code></pre><p>Convert two one-dimensional vectors or matrices into a lower triangular matrix or a 3D tensor.</p><p><strong>Arguments</strong></p><ul><li><code>diag::AbstractVecOrMat</code>: The input vector or matrix to be converted into the diagonal of the matrix. If it&#39;s a matrix, each column is considered as a separate vector.</li><li><code>lower::AbstractVecOrMat</code>: The input vector or matrix to be converted into the lower triangular part of the matrix. The length of this vector or the number of rows in this matrix should be a triangular number (i.e., the sum of the first <code>n</code> natural numbers for some <code>n</code>). If it&#39;s a matrix, each column is considered the lower part of a separate lower triangular matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A lower triangular matrix or a 3D tensor where each slice is a lower triangular matrix constructed from <code>diag</code> and <code>lower</code>.</li></ul><p><strong>Description</strong></p><p>This function constructs a lower triangular matrix or a 3D tensor from two input vectors or matrices, <code>diag</code> and <code>lower</code>. The <code>diag</code> vector or matrix provides the diagonal elements of the matrix, while the <code>lower</code> vector or matrix provides the elements below the diagonal. The function uses a comprehension to construct the matrix or tensor, with the <code>lower_index</code> function calculating the appropriate index in the <code>lower</code> vector or matrix for each element below the diagonal.</p><p><strong>GPU Support</strong></p><p>The function supports both CPU and GPU arrays. For GPU arrays, the data is first transferred to the CPU, the lower triangular matrix or tensor is constructed, and then it is transferred back to the GPU.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.vec_mat_vec_batched" href="#AutoEncoderToolkit.utils.vec_mat_vec_batched"><code>AutoEncoderToolkit.utils.vec_mat_vec_batched</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vec_mat_vec_batched(
    v::AbstractVector, 
    M::AbstractMatrix, 
    w::AbstractVector
)</code></pre><p>Compute the product of a vector, a matrix, and another vector in the form v̲ᵀ M̲̲ w̲.</p><p>This function takes two vectors <code>v</code> and <code>w</code>, and a matrix <code>M</code>, and computes the product v̲ M̲̲ w̲. This function is added for consistency when calling multiple dispatch.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractVector</code>: A <code>d</code> dimensional vector.</li><li><code>M::AbstractMatrix</code>: A <code>d×d</code> matrix.</li><li><code>w::AbstractVector</code>: A <code>d</code> dimensional vector.</li></ul><p><strong>Returns</strong></p><p>A scalar which is the result of the product v̲ M̲̲ w̲ for the corresponding vectors and matrix.</p><p><strong>Notes</strong></p><p>This function uses the <code>LinearAlgebra.dot</code> function to perform the multiplication of the matrix <code>M</code> with the vector <code>w</code>. The resulting vector is then element-wise multiplied with the vector <code>v</code> and summed over the dimensions to obtain the final result. This function is added for consistency when calling multiple dispatch.</p></div></section><section><div><pre><code class="language-julia hljs">vec_mat_vec_batched(
    v::AbstractMatrix, 
    M::AbstractArray, 
    w::AbstractMatrix
)</code></pre><p>Compute the batched product of vectors and matrices in the form v̲ᵀ M̲̲ w̲.</p><p>This function takes two matrices <code>v</code> and <code>w</code>, and a 3D array <code>M</code>, and computes the batched product v̲ M̲̲ w̲. The computation is performed in a broadcasted manner using the <code>Flux.batched_vec</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractMatrix</code>: A <code>d×n</code> matrix, where <code>d</code> is the dimension of the vectors and <code>n</code> is the number of vectors.</li><li><code>M::AbstractArray</code>: A <code>d×d×n</code> array, where <code>d</code> is the dimension of the matrices and <code>n</code> is the number of matrices.</li><li><code>w::AbstractMatrix</code>: A <code>d×n</code> matrix, where <code>d</code> is the dimension of the vectors and <code>n</code> is the number of vectors.</li></ul><p><strong>Returns</strong></p><p>An <code>n</code> dimensional array where each element is the result of the product v̲ M̲̲ w̲ for the corresponding vectors and matrix.</p><p><strong>Notes</strong></p><p>This function uses the <code>Flux.batched_vec</code> function to perform the batched multiplication of the matrices in <code>M</code> with the vectors in <code>w</code>. The resulting vectors are then element-wise multiplied with the vectors in <code>v</code> and summed over the dimensions to obtain the final result.</p></div></section><section><div><pre><code class="language-julia hljs">vec_mat_vec_batched(
    v::AbstractVector{T}, 
    M::AbstractMatrix{S}, 
    w::AbstractVector{T}
) where {T&lt;:TaylorDiff.TaylorScalar{Float32,2},S&lt;:Number}</code></pre><p>Compute the product of a vector and a matrix in the form v̲ᵀ M̲ w̲ for a specific type of matrix and vectors.</p><p>This function takes two vectors <code>v</code> and <code>w</code> of type <code>TaylorDiff.TaylorScalar{Float32,2}</code>, and a matrix <code>M</code> of type <code>Number</code>, and computes the product v̲ M̲ w̲. The computation is performed by first performing the matrix-vector multiplication M̲ w̲, and then computing the dot product of the resulting vector with <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractVector{T}</code>: A <code>d</code> dimensional vector. <code>T</code> is a subtype of <code>TaylorDiff.TaylorScalar{Float32,2}</code>.</li><li><code>M::AbstractMatrix{S}</code>: A <code>d×d</code> matrix. <code>S</code> is a subtype of <code>Number</code>.</li><li><code>w::AbstractVector{T}</code>: A <code>d</code> dimensional vector. <code>T</code> is a subtype of <code>TaylorDiff.TaylorScalar{Float32,2}</code>.</li></ul><p><strong>Returns</strong></p><p>A scalar which is the result of the product v̲ M̲ w̲.</p><p><strong>Notes</strong></p><p>This function uses the <code>dot</code> function to compute the final dot product.</p></div></section><section><div><pre><code class="language-julia hljs">vec_mat_vec_batched(
    v::AbstractMatrix{T}, 
    M::AbstractArray{S,3}, 
    w::AbstractMatrix{T}
) where {T&lt;:TaylorDiff.TaylorScalar{Float32,2},S&lt;:Number}</code></pre><p>Compute the batched product of vectors and matrices in the form v̲ᵀ M̲̲ w̲ for a specific type of matrices and vectors.</p><p>This function takes two matrices <code>v</code> and <code>w</code> of type <code>TaylorDiff.TaylorScalar{Float32,2}</code>, and a 3D array <code>M</code> of type <code>Number</code>, and computes the batched product v̲ M̲̲ w̲. The computation is performed by first extracting each slice of <code>M</code> and each column of <code>w</code>, then performing the vector-matrix multiplication for each pair of slices, and finally computing the element-wise multiplication of the resulting matrix with <code>v</code> and summing over the dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractMatrix{T}</code>: A <code>d×n</code> matrix, where <code>d</code> is the dimension of the vectors and <code>n</code> is the number of vectors. <code>T</code> is a subtype of <code>TaylorDiff.TaylorScalar{Float32,2}</code>.</li><li><code>M::AbstractArray{S,3}</code>: A <code>d×d×n</code> array, where <code>d</code> is the dimension of the matrices and <code>n</code> is the number of matrices. <code>S</code> is a subtype of <code>Number</code>.</li><li><code>w::AbstractMatrix{T}</code>: A <code>d×n</code> matrix, where <code>d</code> is the dimension of the vectors and <code>n</code> is the number of vectors. <code>T</code> is a subtype of <code>TaylorDiff.TaylorScalar{Float32,2}</code>.</li></ul><p><strong>Returns</strong></p><p>An <code>n</code> dimensional array where each element is the result of the product v̲ M̲̲ w̲ for the corresponding vectors and matrix.</p><p><strong>Notes</strong></p><p>This function uses the <code>eachslice</code> and <code>eachcol</code> functions to extract the slices of <code>M</code> and the columns of <code>w</code>, respectively. It then uses a list comprehension to perform the vector-matrix multiplication for each pair of slices, and finally computes the element-wise multiplication of the resulting matrix with <code>v</code> and sums over the dimensions to obtain the final result.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.slogdet" href="#AutoEncoderToolkit.utils.slogdet"><code>AutoEncoderToolkit.utils.slogdet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">slogdet(A::AbstractArray{T}; check::Bool=false) where {T&lt;:Number}</code></pre><p>Compute the log determinant of a positive-definite matrix <code>A</code> or a 3D array of such matrices.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray{T}</code>: A positive-definite matrix or a 3D array of positive-definite matrices whose log determinant is to be computed.  </li><li><code>check::Bool=false</code>: A flag that determines whether to check if the input matrix <code>A</code> is positive-definite. Defaults to <code>false</code> due to numerical instability.</li></ul><p><strong>Returns</strong></p><ul><li>The log determinant of <code>A</code>. If <code>A</code> is a 3D array, returns a 1D array of log determinants, one for each slice along the third dimension of <code>A</code>.</li></ul><p><strong>Description</strong></p><p>This function computes the log determinant of a positive-definite matrix <code>A</code> or a 3D array of such matrices. It first computes the Cholesky decomposition of <code>A</code>, and then calculates the log determinant as twice the sum of the log of the diagonal elements of the lower triangular matrix from the Cholesky decomposition.</p><p><strong>Conditions</strong></p><p>The input matrix <code>A</code> must be a positive-definite matrix, i.e., it must be symmetric and all its eigenvalues must be positive. If <code>check</code> is set to <code>true</code>, the function will throw an error if <code>A</code> is not positive-definite.</p><p><strong>GPU Support</strong></p><p>The function supports both CPU and GPU arrays. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.sample_MvNormalCanon" href="#AutoEncoderToolkit.utils.sample_MvNormalCanon"><code>AutoEncoderToolkit.utils.sample_MvNormalCanon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_MvNormalCanon(Σ⁻¹::AbstractArray{T}) where {T&lt;:Number}</code></pre><p>Draw a random sample from a multivariate normal distribution in canonical form.</p><p><strong>Arguments</strong></p><ul><li><code>Σ⁻¹::AbstractArray{T}</code>: The precision matrix (inverse of the covariance matrix) of the multivariate normal distribution. This can be a 2D array (matrix) or a 3D array.</li></ul><p><strong>Returns</strong></p><ul><li>A random sample drawn from the multivariate normal distribution specified by the input precision matrix. If <code>Σ⁻¹</code> is a 3D array, returns a 2D array of samples, one for each slice along the third dimension of <code>Σ⁻¹</code>.</li></ul><p><strong>Description</strong></p><p>This function draws a random sample from a multivariate normal distribution specified by a precision matrix <code>Σ⁻¹</code>. The precision matrix can be a 2D array (matrix) or a 3D array. If <code>Σ⁻¹</code> is a 3D array, the function draws a sample for each slice along the third dimension of <code>Σ⁻¹</code>.</p><p>The function first inverts the precision matrix to obtain the covariance matrix, then performs a Cholesky decomposition of the covariance matrix. It then draws a sample from a standard normal distribution and multiplies it by the lower triangular matrix from the Cholesky decomposition to obtain the final sample.</p><p><strong>GPU Support</strong></p><p>The function supports both CPU and GPU arrays.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.unit_vector" href="#AutoEncoderToolkit.utils.unit_vector"><code>AutoEncoderToolkit.utils.unit_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unit_vector(x::AbstractVector, i::Int)</code></pre><p>Create a unit vector of the same length as <code>x</code> with the <code>i</code>-th element set to 1.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector</code>: The vector whose length is used to determine the dimension of the unit vector.</li><li><code>i::Int</code>: The index of the element to be set to 1.</li></ul><p><strong>Returns</strong></p><ul><li>A unit vector of type <code>eltype(x)</code> and length equal to <code>x</code> with the <code>i</code>-th element set to 1.</li></ul><p><strong>Description</strong></p><p>This function creates a unit vector of the same length as <code>x</code> with the <code>i</code>-th element set to 1. All other elements are set to 0.</p><p><strong>Note</strong></p><p>This function is marked with the <code>@ignore_derivatives</code> macro from the <code>ChainRulesCore</code> package, which means that all AutoDiff backends will ignore any call to this function when computing gradients.</p></div></section><section><div><pre><code class="language-julia hljs">unit_vector(x::AbstractMatrix, i::Int)</code></pre><p>Create a unit vector of the same length as the number of rows in <code>x</code> with the <code>i</code>-th element set to 1.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix</code>: The matrix whose number of rows is used to determine the dimension of the unit vector.</li><li><code>i::Int</code>: The index of the element to be set to 1.</li></ul><p><strong>Returns</strong></p><ul><li>A unit vector of type <code>eltype(x)</code> and length equal to the number of rows in <code>x</code> with the <code>i</code>-th element set to 1.</li></ul><p><strong>Description</strong></p><p>This function creates a unit vector of the same length as the number of rows in <code>x</code> with the <code>i</code>-th element set to 1. All other elements are set to 0. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.finite_difference_gradient" href="#AutoEncoderToolkit.utils.finite_difference_gradient"><code>AutoEncoderToolkit.utils.finite_difference_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finite_difference_gradient(
    f::Function,
    x::AbstractVecOrMat;
    fdtype::Symbol=:central
)</code></pre><p>Compute the finite difference gradient of a function <code>f</code> at a point <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function for which the gradient is to be computed. This function must return a scalar value.</li><li><code>x::AbstractVecOrMat</code>: The point at which the gradient is to be computed. Can be a vector or a matrix. If a matrix, each column represents a point where the function f is to be evaluated and the derivative computed.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>fdtype::Symbol=:central</code>: The finite difference type. It can be either <code>:forward</code> or <code>:central</code>. Defaults to <code>:central</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A vector or a matrix representing the gradient of <code>f</code> at <code>x</code>, depending on the input type of <code>x</code>.</li></ul><p><strong>Description</strong></p><p>This function computes the finite difference gradient of a function <code>f</code> at a point <code>x</code>. The gradient is a vector or a matrix where the <code>i</code>-th element is the partial derivative of <code>f</code> with respect to the <code>i</code>-th element of <code>x</code>.</p><p>The partial derivatives are computed using the forward or central difference formula, depending on the <code>fdtype</code> argument:</p><ul><li>Forward difference formula: ∂f/∂xᵢ ≈ [f(x + ε * eᵢ) - f(x)] / ε</li><li>Central difference formula: ∂f/∂xᵢ ≈ [f(x + ε * eᵢ) - f(x - ε * eᵢ)] / 2ε</li></ul><p>where ε is the step size and eᵢ is the <code>i</code>-th unit vector.</p><p><strong>GPU Support</strong></p><p>This function supports both CPU and GPU arrays.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.utils.taylordiff_gradient" href="#AutoEncoderToolkit.utils.taylordiff_gradient"><code>AutoEncoderToolkit.utils.taylordiff_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    taylordiff_gradient(
            f::Function,
            x::AbstractVecOrMat
    )</code></pre><p>Compute the gradient of a function <code>f</code> at a point <code>x</code> using Taylor series differentiation.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function for which the gradient is to be computed. This must be a scalar function.</li><li><code>x::AbstractVecOrMat</code>: The point at which the gradient is to be computed. Can be a vector or a matrix. If a matrix, each column represents a point where the function f is to be evaluated and the derivative computed.</li></ul><p><strong>Returns</strong></p><ul><li>A vector or a matrix representing the gradient of <code>f</code> at <code>x</code>, depending on the input type of <code>x</code>.</li></ul><p><strong>Description</strong></p><p>This function computes the gradient of a function <code>f</code> at a point <code>x</code> using Taylor series differentiation. The gradient is a vector or a matrix where the <code>i</code>-th element or column is the partial derivative of <code>f</code> with respect to the <code>i</code>-th element of <code>x</code>.</p><p>The partial derivatives are computed using the TaylorDiff.derivative function.</p><p><strong>GPU Support</strong></p><p>This function currently only supports CPU arrays.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../diffgeo/">« Differential Geometry</a><a class="docs-footer-nextpage" href="../guidelines/">Community Guidelines »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 11 July 2024 19:46">Thursday 11 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
