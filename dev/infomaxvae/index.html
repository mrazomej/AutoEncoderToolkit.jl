<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>InfoMax-VAE · AutoEncoderToolkit</title><meta name="title" content="InfoMax-VAE · AutoEncoderToolkit"/><meta property="og:title" content="InfoMax-VAE · AutoEncoderToolkit"/><meta property="twitter:title" content="InfoMax-VAE · AutoEncoderToolkit"/><meta name="description" content="Documentation for AutoEncoderToolkit."/><meta property="og:description" content="Documentation for AutoEncoderToolkit."/><meta property="twitter:description" content="Documentation for AutoEncoderToolkit."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="AutoEncoderToolkit logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="AutoEncoderToolkit logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AutoEncoderToolkit</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../encoders/">Encoders &amp; Decoders</a></li><li><a class="tocitem" href="../layers/">Custom Layers</a></li><li><a class="tocitem" href="../ae/">Deterministic Autoencoders</a></li><li><a class="tocitem" href="../vae/">VAE / β-VAE</a></li><li><a class="tocitem" href="../mmdvae/">MMD-VAE (InfoVAE)</a></li><li class="is-active"><a class="tocitem" href>InfoMax-VAE</a><ul class="internal"><li><a class="tocitem" href="#References"><span>References</span></a></li><li><a class="tocitem" href="#MutualInfoChain"><span><code>MutualInfoChain</code> struct</span></a></li><li><a class="tocitem" href="#InfoMaxVAE"><span><code>InfoMaxVAE</code> struct</span></a></li><li><a class="tocitem" href="#Forward-pass"><span>Forward pass</span></a></li><li><a class="tocitem" href="#[Loss-functions]"><span>[Loss functions]</span></a></li><li><a class="tocitem" href="#Training"><span>Training</span></a></li><li><a class="tocitem" href="#Other-Functions"><span>Other Functions</span></a></li><li><a class="tocitem" href="#Default-initializations"><span>Default initializations</span></a></li></ul></li><li><a class="tocitem" href="../hvae/">HVAE</a></li><li><a class="tocitem" href="../rhvae/">RHVAE</a></li><li><a class="tocitem" href="../diffgeo/">Differential Geometry</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>InfoMax-VAE</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>InfoMax-VAE</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="InfoMaxVAEsmodule"><a class="docs-heading-anchor" href="#InfoMaxVAEsmodule">InfoMax VAE</a><a id="InfoMaxVAEsmodule-1"></a><a class="docs-heading-anchor-permalink" href="#InfoMaxVAEsmodule" title="Permalink"></a></h1><p>The InfoMax VAE is a variant of the Variational Autoencoder (VAE) that aims to explicitly account for the maximization of mutual information between the latent space representation and the input data. The main difference between the InfoMax VAE and the <a href="../mmdvae/#MMDVAEsmodule">MMD-VAE (InfoVAE)</a> is that rather than using the Maximum-Mean Discrepancy (MMD) as a measure of the &quot;distance&quot; between the latent space, the InfoMax VAE explicitly models the mutual information between latent representations and data inputs via a separate neural network. The loss function for this separate network then takes the form of a variational lower bound on the mutual information between the latent space and the input data.</p><p>Because of the need of this separate network, the <a href="#InfoMaxVAE"><code>InfoMaxVAE</code></a> struct in <code>AutoEncoderToolkit.jl</code> takes two arguments to construct: the original <a href="../vae/#VAEstruct"><code>VAE</code></a> struct and a network to compute the mutual information. To properly deploy all relevant functions associated with this second network, we also provide a <a href="#MutualInfoChain"><code>MutualInfoChain</code></a> struct.</p><p>Furthermore, because of the two networks and the way the training algorithm is set up, the loss function for the InfoMax VAE includes two separate loss functions: one for the <a href="#miloss"><code>MutualInfoChain</code></a> and one for the <a href="#infomaxloss"><code>InfoMaxVAE</code></a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><blockquote><p>Rezaabad, A. L. &amp; Vishwanath, S. Learning Representations by Maximizing Mutual Information in Variational Autoencoders. Preprint at http://arxiv.org/abs/1912.13361 (2020).</p></blockquote><h2 id="MutualInfoChain"><a class="docs-heading-anchor" href="#MutualInfoChain"><code>MutualInfoChain</code> struct</a><a id="MutualInfoChain-1"></a><a class="docs-heading-anchor-permalink" href="#MutualInfoChain" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain" href="#AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain"><code>AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MutualInfoChain</code></pre><p>A <code>MutualInfoChain</code> is used to compute the variational mutual information when training an InfoMaxVAE. The chain is composed of a series of layers that must end with a single output: the mutual information between the latent variables and the input data.</p><p><strong>Arguments</strong></p><ul><li><code>data::Union{Flux.Dense,Flux.Chain}</code>: The data layer of the MutualInfoChain. This layer is used to input the data.</li><li><code>latent::Union{Flux.Dense,Flux.Chain}</code>: The latent layer of the MutualInfoChain. This layer is used to input the latent variables.</li><li><code>mlp::Flux.Chain</code>: A multi-layer perceptron (MLP) that is used to compute the mutual information between the inputs and the latent representations. The MLP takes as input the latent variables and outputs a scalar representing the estimated variational mutual information.</li></ul><p><strong>Citation</strong></p><blockquote><p>Rezaabad, A. L. &amp; Vishwanath, S. Learning Representations by Maximizing Mutual Information in Variational Autoencoders. in 2020 IEEE International Symposium on Information Theory (ISIT) 2729–2734 (IEEE, 2020). doi:10.1109/ISIT44484.2020.9174424.</p></blockquote><p><strong>Note</strong></p><p>If the input data is not a flat array, make sure to include a flattening layer within <code>data</code>.</p></div></section></article><h2 id="InfoMaxVAE"><a class="docs-heading-anchor" href="#InfoMaxVAE"><code>InfoMaxVAE</code> struct</a><a id="InfoMaxVAE-1"></a><a class="docs-heading-anchor-permalink" href="#InfoMaxVAE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.InfoMaxVAE" href="#AutoEncoderToolkit.InfoMaxVAEs.InfoMaxVAE"><code>AutoEncoderToolkit.InfoMaxVAEs.InfoMaxVAE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">`InfoMaxVAE &lt;: AbstractVariationalAutoEncoder`</code></pre><p><code>struct</code> encapsulating an InfoMax variational autoencoder (InfoMaxVAE), an architecture designed to enhance the VAE framework by maximizing mutual information between the inputs and the latent representations, as per the methods described by Rezaabad and Vishwanath (2020).</p><p>The model aims to learn representations that preserve mutual information with the input data, arguably capturing more meaningful factors of variation.</p><p><strong>Fields</strong></p><ul><li><code>vae::VAE</code>: The core variational autoencoder, consisting of an encoder that maps input data into a latent space representation, and a decoder that attempts to reconstruct the input from the latent representation.</li><li><code>mi::MutualInfoChain</code>: A multi-layer perceptron (MLP) that estimates the mutual information between the input data and the latent representations.</li></ul><p><strong>Usage</strong></p><p>The <code>InfoMaxVAE</code> struct is utilized in a similar manner to a standard VAE, with the added capability of mutual information maximization as part of the training process. This involves an additional loss term that considers the output of the <code>mi</code> network to encourage latent representations that are informative about the input data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Assuming definitions for `encoder`, `decoder`, and `mi` are provided:
info_max_vae = InfoMaxVAE(VAE(encoder, decoder), mi)

# During training, one would maximize both the variational lower bound and the 
# mutual information estimate provided by `mlp`.</code></pre><p><strong>Citation</strong></p><blockquote><p>Rezaabad, A. L. &amp; Vishwanath, S. Learning Representations by Maximizing Mutual Information in Variational Autoencoders. in 2020 IEEE International Symposium on Information Theory (ISIT) 2729–2734 (IEEE, 2020). doi:10.1109/ISIT44484.2020.9174424.</p></blockquote></div></section></article><h2 id="Forward-pass"><a class="docs-heading-anchor" href="#Forward-pass">Forward pass</a><a id="Forward-pass-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-pass" title="Permalink"></a></h2><h3 id="Mutual-Information-Network"><a class="docs-heading-anchor" href="#Mutual-Information-Network">Mutual Information Network</a><a id="Mutual-Information-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Mutual-Information-Network" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain-Tuple{AbstractArray, AbstractVecOrMat}" href="#AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain-Tuple{AbstractArray, AbstractVecOrMat}"><code>AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(mi::MutualInfoChain)(x::AbstractArray, z::AbstractVecOrMat)</code></pre><p>Forward pass function for the MutualInfoChain, which applies the MLP to an input x.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: The input array to be processed. The last dimension represents each data sample.</li><li><code>z::AbstractVecOrMat</code>: The latent representation of the input data. The last dimension represents each data sample.</li></ul><p><strong>Returns</strong></p><ul><li>The result of applying the MutualInfoChain to the input data and the latent representation simultaneously.</li></ul><p><strong>Description</strong></p><p>This function applies the MLP (Multilayer Perceptron) of a MutualInfoChain instance to an input array. The MLP is a type of neural network used in the MutualInfoChain for processing the input data.</p></div></section></article><h3 id="InfoMax-VAE"><a class="docs-heading-anchor" href="#InfoMax-VAE">InfoMax VAE</a><a id="InfoMax-VAE-1"></a><a class="docs-heading-anchor-permalink" href="#InfoMax-VAE" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.InfoMaxVAE-Tuple{AbstractArray}" href="#AutoEncoderToolkit.InfoMaxVAEs.InfoMaxVAE-Tuple{AbstractArray}"><code>AutoEncoderToolkit.InfoMaxVAEs.InfoMaxVAE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(vae::InfoMaxVAE)(x::AbstractArray; latent::Bool=false)</code></pre><p>Processes the input data <code>x</code> through an InfoMaxVAE, which consists of an encoder, a decoder, and a multi-layer perceptron (MLP) to estimate variational mutual information.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: The data to be decoded. If array, the last dimension contains each data sample. </li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>latent::Bool</code>: If <code>true</code>, returns a dictionary with latent variables and mutual information estimations along with the reconstruction. Defaults to <code>false</code>.</li><li><code>seed::Union{Nothing,Int}</code>: Optional argument. The seed for the random number generator used for shuffling the latent codes. If not provided, a random seed will be used.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>latent=false</code>: The decoder output as a <code>NamedTuple</code>.</li><li>If <code>latent=true</code>: A <code>NamedTuple</code> with the <code>:vae</code> field that contains the outputs of the VAE, and the <code>:mi</code> field that contains the estimate of the variational mutual information. Note that this estimate requires shuffling the latent codes between data samples. Therefore, it is only meaningful for batch data cases.</li></ul><p><strong>Description</strong></p><p>This function first encodes the input <code>x</code> . It then samples from this distribution using the reparametrization trick. The sampled latent vectors are then decoded, and the MutualInfoChain is used to estimate the mutual information.</p><p><strong>Note</strong></p><p>Ensure the input data <code>x</code> matches the expected input dimensionality for the encoder in the InfoMaxVAE.</p></div></section></article><h2 id="[Loss-functions]"><a class="docs-heading-anchor" href="#[Loss-functions]">[Loss functions]</a><a id="[Loss-functions]-1"></a><a class="docs-heading-anchor-permalink" href="#[Loss-functions]" title="Permalink"></a></h2><h3 id="miloss"><a class="docs-heading-anchor" href="#miloss">Mutual Information Network</a><a id="miloss-1"></a><a class="docs-heading-anchor-permalink" href="#miloss" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.miloss" href="#AutoEncoderToolkit.InfoMaxVAEs.miloss"><code>AutoEncoderToolkit.InfoMaxVAEs.miloss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">miloss(
    vae::VAE,
    mi::MutualInfoChain,
    x::AbstractArray;
    regularization::Union{Function,Nothing}=nothing,
    reg_strength::Float32=1.0f0,
    seed::Union{Nothing,Int}=nothing
)</code></pre><p>Calculates the loss for training the MutualInfoChain in the InfoMaxVAE algorithm to estimate mutual information between the input <code>x</code> and the latent representation <code>z</code>. The loss function is based on a variational approximation of mutual information, using the MutualInfoChain&#39;s output <code>g(x, z)</code>. The variational mutual information is then calculated as the difference between the MutualInfoChain&#39;s output for the true <code>x</code> and latent <code>z</code>, and the exponentiated average of the MLP&#39;s output for <code>x</code> and the shuffled latent <code>z_shuffle</code>, adjusted for the regularization term if provided.</p><p><strong>Arguments</strong></p><ul><li><code>vae::VAE</code>: The variational autoencoder.</li><li><code>mi::MutualInfoChain</code>: The MutualInfoChain used for estimating mutual information.</li><li><code>x::AbstractArray</code>: The input vector for the VAE.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>regularization::Union{Function, Nothing}=nothing</code>: A regularization function applied to the MLP&#39;s output.</li><li><code>reg_strength::Float32=1.0f0</code>: The strength of the regularization term.</li><li><code>seed::Union{Nothing,Int}=nothing</code>: The seed for the random number generator used for shuffling the latent codes. If not provided, a random seed will be used.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: The computed loss, representing negative variational mutual information, adjusted by the regularization term.</li></ul><p><strong>Description</strong></p><p>The function computes the loss as follows:</p><p>loss = -sum(I(x; z)) + sum(exp(I(x; z̃) - 1)) + reg<em>strength * reg</em>term</p><p>where <code>I(x; z)</code> is the MLP&#39;s output representing an estimation of mutual information for true <code>x</code> and latent <code>z</code>, and <code>z̃</code> represents shuffled latent variables, meaning, the latent codes are randomly swap between data points.</p><p>The function is used to separately train the MLP to estimate mutual information, which is a component of the larger InfoMaxVAE model.</p><p><strong>Notes</strong></p><ul><li>This function takes the <code>vae</code> and <code>mi</code> instances of an InfoMaxVAE model as separate arguments to be able to compute a gradient only with respect to the <code>mi</code> parameters.</li><li>Ensure that the dimensionality of the input data <code>x</code> aligns with the encoder&#39;s   expected input in the VAE.</li><li>InfoMaxVAEs fully depend on batch training as the estimation of mutual   information depends on shuffling the latent codes. This method works for   large enough batches (≥ 64 samples).</li></ul></div></section></article><h3 id="infomaxloss"><a class="docs-heading-anchor" href="#infomaxloss">InfoMax VAE</a><a id="infomaxloss-1"></a><a class="docs-heading-anchor-permalink" href="#infomaxloss" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.infomaxloss" href="#AutoEncoderToolkit.InfoMaxVAEs.infomaxloss"><code>AutoEncoderToolkit.InfoMaxVAEs.infomaxloss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">infomaxloss(
    vae::VAE,
    mi::MutualInfoChain,
    x::AbstractArray;
    β=1.0f0,
    α=1.0f0,
    n_samples::Int=1,
    reconstruction_loglikelihood::Function=decoder_loglikelihood,
    kl_divergence::Function=encoder_kl,
    regularization::Union{Function,Nothing}=nothing,
    reg_strength::Float32=1.0f0,
    seed::Union{Nothing,Int}=nothing
)</code></pre><p>Computes the loss for an InfoMax variational autoencoder (VAE) with mutual information constraints, by averaging over <code>n_samples</code> latent space samples.</p><p>The loss function combines the reconstruction loss with the Kullback-Leibler (KL) divergence, the variational mutual information between input and latent representations, and possibly a regularization term, defined as:</p><p>loss = -⟨log p(x|z)⟩ + β × Dₖₗ[qᵩ(z|x) || p(z)] - α × I(x;z) + reg<em>strength × reg</em>term</p><p>Where:</p><ul><li><code>⟨log p(x|z)⟩</code> is the expected log likelihood of the probabilistic decoder. -</li></ul><p><code>Dₖₗ[qᵩ(z|x) || p(z)]</code> is the KL divergence between the approximated encoder and the prior over the latent space.</p><ul><li><code>I(x;z)</code> is the variational mutual information between the inputs <code>x</code> and the latent variables <code>z</code>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>vae::VAE</code>: A VAE model with encoder and decoder networks.</li><li><code>mi::MutualInfoChain</code>: A MutualInfoChain instance used to estimate mutual information term.</li><li><code>x::AbstractArray</code>: Input data. The last dimension represents each data sample.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>β::Float32=1.0f0</code>: Weighting factor for the KL-divergence term, used for annealing.</li><li><code>α::Float32=1.0f0</code>: Weighting factor for the mutual information term.</li><li><code>n_samples::Int=1</code>: The number of samples to draw from the latent space when computing the loss.</li><li><code>reconstruction_loglikelihood::Function=decoder_loglikelihood</code>: A function that computes the log likelihood of the decoder&#39;s output.</li><li><code>kl_divergence::Function=encoder_kl</code>: A function that computes the KL divergence between the encoder&#39;s output and the prior.</li><li><code>regularization::Union{Function, Nothing}=nothing</code>: A function that computes the regularization term based on the VAE outputs. Should return a Float32.</li><li><code>reg_strength::Float32=1.0f0</code>: The strength of the regularization term.</li><li><code>seed::Union{Nothing,Int}</code>: The seed for the random number generator used for shuffling the latent codes. If not provided, a random seed will be used.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: The computed average loss value for the input <code>x</code> and its reconstructed counterparts over <code>n_samples</code> samples, including possible regularization terms and the mutual information constraint.</li></ul><p><strong>Note</strong></p><ul><li>This function takes the <code>vae</code> and <code>mi</code> instances of an InfoMaxVAE model as separate arguments to be able to compute a gradient only with respect to the <code>vae</code> parameters.</li><li>Ensure that the input data <code>x</code> match the expected input dimensionality for the encoder in the VAE.</li><li>InfoMaxVAEs fully depend on batch training as the estimation of mutual information depends on shuffling the latent codes. This method works for large enough batches (≥ 64 samples).</li></ul></div></section><section><div><pre><code class="language-julia hljs">infomaxloss(
    vae::VAE,
    mi::MutualInfoChain,
    x_in::AbstractArray,
    x_out::AbstractArray;
    β=1.0f0,
    α=1.0f0,
    n_samples::Int=1,
    reconstruction_loglikelihood::Function=decoder_loglikelihood,
    kl_divergence::Function=encoder_kl,
    regularization::Union{Function,Nothing}=nothing,
    reg_strength::Float32=1.0f0,
    seed::Union{Nothing,Int}=nothing
)</code></pre><p>Computes the loss for an InfoMax variational autoencoder (VAE) with mutual information constraints, by averaging over <code>n_samples</code> latent space samples.</p><p>The loss function combines the reconstruction loss with the Kullback-Leibler (KL) divergence, the variational mutual information between input and latent representations, and possibly a regularization term, defined as:</p><p>loss = -⟨log p(x|z)⟩ + β × Dₖₗ[qᵩ(z|x) || p(z)] - α × I(x;z) + reg<em>strength × reg</em>term</p><p>Where:</p><ul><li><code>⟨log p(x|z)⟩</code> is the expected log likelihood of the probabilistic decoder. -</li></ul><p><code>Dₖₗ[qᵩ(z|x) || p(z)]</code> is the KL divergence between the approximated encoder and the prior over the latent space.</p><ul><li><code>I(x;z)</code> is the variational mutual information between the inputs <code>x</code> and the latent variables <code>z</code>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>vae::VAE</code>: A VAE model with encoder and decoder networks.</li><li><code>mi::MutualInfoChain</code>: A MutualInfoChain instance used to estimate mutual information term.</li><li><code>x_in::AbstractArray</code>: Input matrix. The last dimension represents each data sample.</li><li><code>x_out::AbstractArray</code>: Output matrix against wich reconstructions are compared. The last dimension represents each data sample.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>β::Float32=1.0f0</code>: Weighting factor for the KL-divergence term, used for annealing.</li><li><code>α::Float32=1.0f0</code>: Weighting factor for the mutual information term.</li><li><code>n_samples::Int=1</code>: The number of samples to draw from the latent space when computing the loss.</li><li><code>reconstruction_loglikelihood::Function=decoder_loglikelihood</code>: A function that computes the log likelihood of the decoder&#39;s output.</li><li><code>kl_divergence::Function=encoder_kl</code>: A function that computes the KL divergence between the encoder&#39;s output and the prior.</li><li><code>regularization::Union{Function, Nothing}=nothing</code>: A function that computes the regularization term based on the VAE outputs. Should return a Float32.</li><li><code>reg_strength::Float32=1.0f0</code>: The strength of the regularization term.</li><li><code>seed::Union{Nothing,Int}</code>: The seed for the random number generator used for shuffling the latent codes. If not provided, a random seed will be used.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: The computed average loss value for the input <code>x</code> and its reconstructed counterparts over <code>n_samples</code> samples, including possible regularization terms and the mutual information constraint.</li></ul><p><strong>Note</strong></p><ul><li>This function takes the <code>vae</code> and <code>mi</code> instances of an InfoMaxVAE model as separate arguments to be able to compute a gradient only with respect to the <code>vae</code> parameters.</li><li>Ensure that the input data <code>x</code> match the expected input dimensionality for the encoder in the VAE.</li><li>InfoMaxVAEs fully depend on batch training as the estimation of mutual information depends on shuffling the latent codes. This method works for large enough batches (≥ 64 samples).</li></ul></div></section></article><h2 id="Training"><a class="docs-heading-anchor" href="#Training">Training</a><a id="Training-1"></a><a class="docs-heading-anchor-permalink" href="#Training" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.train!" href="#AutoEncoderToolkit.InfoMaxVAEs.train!"><code>AutoEncoderToolkit.InfoMaxVAEs.train!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    train!(
        infomaxvae, x, opt; 
        infomaxloss_function=infomaxloss,
        infomaxloss_kwargs, 
        miloss_function=miloss, 
        miloss_kwargs,
        loss_return::Bool=false,
        verbose::Bool=false
    )</code></pre><p>Customized training function to update parameters of an InfoMax variational autoencoder (VAE) given a loss function of the specified form.</p><p>The InfoMax VAE loss function can be defined as:</p><pre><code class="nohighlight hljs">loss_infoMax = argmin -⟨log p(x|z)⟩ + β Dₖₗ(qᵩ(z) || p(z)) -
                                 α [⟨g(x, z)⟩ - ⟨exp(g(x, z) - 1)⟩],</code></pre><p>where <code>⟨log p(x|z)⟩</code> is the expected log likelihood of the probabilistic decoder, <code>Dₖₗ[qᵩ(z) || p(z)]</code> is the KL divergence between the approximated encoder distribution and the prior over the latent space, and <code>g(x, z)</code> is the output of the MutualInfoChain estimating the mutual information between the input data and the latent representation.</p><p>This function simultaneously optimizes two neural networks: the VAE itself and a multi-layer perceptron <code>MutualInfoChain</code> used to compute the mutual information between input and latent variables.</p><p><strong>Arguments</strong></p><ul><li><code>infomaxvae::InfoMaxVAE</code>: Struct containing the elements of an InfoMax VAE.</li><li><code>x::AbstractArray</code>: Matrix containing the data on which to evaluate the loss function. Each column represents a single data point.</li><li><code>opt::NamedTuple</code>: State of the optimizer for updating parameters. Typically initialized using <code>Flux.Optimisers.update!</code>.</li></ul><p><strong>Optional Keyword arguments</strong></p><ul><li><code>infomaxloss_function::Function</code>: The loss function to be used during training for the VAE, defaulting to <code>infomaxloss</code>.</li><li><code>infomaxloss_kwargs::Union{NamedTuple,Dict}</code>: Additional keyword arguments to be passed to the VAE loss function.</li><li><code>miloss_function::Function</code>: The loss function to be used during training for the MLP computing the variational free energy, defaulting to <code>miloss</code>.</li><li><code>miloss_kwargs::Union{NamedTuple,Dict}</code>: Additional keyword arguments to be passed to the MutualInfoChain loss function.</li><li><code>loss_return::Bool</code>: If <code>true</code>, the function returns the loss values for the VAE and MutualInfoChain. Defaults to <code>false</code>.</li><li><code>verbose::Bool</code>: If <code>true</code>, the function prints the loss values for the VAE and MutualInfoChain. Defaults to <code>false</code>.</li></ul><p><strong>Description</strong></p><p>Performs one step of gradient descent on the InfoMaxVAE loss function to jointly train the VAE and MutualInfoChain. The VAE parameters are updated to minimize the InfoMaxVAE loss, while the MutualInfoChain parameters are updated to maximize the estimated mutual information. The function allows for customization of loss hyperparameters during training.</p><p><strong>Notes</strong></p><ul><li>Ensure that the dimensionality of the input data <code>x</code> aligns with the encoder&#39;s expected input in the VAE.</li><li>InfoMaxVAEs fully depend on batch training as the estimation of mutual information depends on shuffling the latent codes. This method works best for large enough batches (≥ 64 samples).</li></ul></div></section><section><div><pre><code class="language-julia hljs">    train!(
        infomaxvae, x, opt; 
        infomaxloss_function=infomaxloss,
        infomaxloss_kwargs, 
        miloss_function=miloss, 
        miloss_kwargs,
        loss_return::Bool=false,
        verbose::Bool=false
    )</code></pre><p>Customized training function to update parameters of an InfoMax variational autoencoder (VAE) given a loss function of the specified form.</p><p>The InfoMax VAE loss function can be defined as:</p><pre><code class="nohighlight hljs">loss_infoMax = argmin -⟨log p(x|z)⟩ + β Dₖₗ(qᵩ(z) || p(z)) -
                                 α [⟨g(x, z)⟩ - ⟨exp(g(x, z) - 1)⟩],</code></pre><p>where <code>⟨log p(x|z)⟩</code> is the expected log likelihood of the probabilistic decoder, <code>Dₖₗ[qᵩ(z) || p(z)]</code> is the KL divergence between the approximated encoder distribution and the prior over the latent space, and <code>g(x, z)</code> is the output of the MutualInfoChain estimating the mutual information between the input data and the latent representation.</p><p>This function simultaneously optimizes two neural networks: the VAE itself and a multi-layer perceptron <code>MutualInfoChain</code> used to compute the mutual information between input and latent variables.</p><p><strong>Arguments</strong></p><ul><li><code>infomaxvae::InfoMaxVAE</code>: Struct containing the elements of an InfoMax VAE.</li><li><code>x::AbstractArray</code>: Matrix containing the data on which to evaluate the loss function. Each column represents a single data point.</li><li><code>opt::NamedTuple</code>: State of the optimizer for updating parameters. Typically initialized using <code>Flux.Optimisers.update!</code>.</li></ul><p><strong>Optional Keyword arguments</strong></p><ul><li><code>infomaxloss_function::Function</code>: The loss function to be used during training for the VAE, defaulting to <code>infomaxloss</code>.</li><li><code>infomaxloss_kwargs::Union{NamedTuple,Dict}</code>: Additional keyword arguments to be passed to the VAE loss function.</li><li><code>miloss_function::Function</code>: The loss function to be used during training for the MutualInfoChain computing the variational free energy, defaulting to <code>miloss</code>.</li><li><code>miloss_kwargs::Union{NamedTuple,Dict}</code>: Additional keyword arguments to be passed to the MutualInfoChain loss function.</li><li><code>loss_return::Bool</code>: If <code>true</code>, the function returns the loss values for the VAE and MLP. Defaults to <code>false</code>.</li></ul><p><strong>Description</strong></p><p>Performs one step of gradient descent on the InfoMaxVAE loss function to jointly train the VAE and MutualInfoChain. The VAE parameters are updated to minimize the InfoMaxVAE loss, while the MutualInfoChain parameters are updated to maximize the estimated mutual information. The function allows for customization of loss hyperparameters during training.</p><p><strong>Notes</strong></p><ul><li>Ensure that the dimensionality of the input data <code>x</code> aligns with the encoder&#39;s expected input in the VAE.</li><li>InfoMaxVAEs fully depend on batch training as the estimation of mutual information depends on shuffling the latent codes. This method works best for large enough batches (≥ 64 samples).</li></ul></div></section></article><h2 id="Other-Functions"><a class="docs-heading-anchor" href="#Other-Functions">Other Functions</a><a id="Other-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.shuffle_latent" href="#AutoEncoderToolkit.InfoMaxVAEs.shuffle_latent"><code>AutoEncoderToolkit.InfoMaxVAEs.shuffle_latent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shuffle_latent(z::AbstractMatrix, seed::Int=Random.seed!())</code></pre><p>Shuffle the elements of the second dimension of a matrix representing latent space points.</p><p><strong>Arguments</strong></p><ul><li><code>z::AbstractMatrix</code>: A matrix representing latent codes. Each column corresponds to a single latent code.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>seed::Union{Nothing, Int}</code>: Optional argument. The seed for the random number generator. If not provided, a random seed will be used.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix</code>: A new matrix with the second dimension shuffled.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.variational_mutual_info" href="#AutoEncoderToolkit.InfoMaxVAEs.variational_mutual_info"><code>AutoEncoderToolkit.InfoMaxVAEs.variational_mutual_info</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">variational_mutual_info(mi, x, z, z_shuffle)</code></pre><p>Compute a variational approximation of the mutual information between the input <code>x</code> and the latent code <code>z</code> using a <code>MutualInfoChain</code>. Note that this estimate requires shuffling the latent codes between data samples. Therefore, it only applies to batch data cases. A single sample will not provide a meaningful estimate.</p><p><strong>Arguments</strong></p><ul><li><code>mi::MutualInfoChain</code>: A MutualInfoChain instance used to estimate mutual information.</li><li><code>x::AbstractArray</code>: Array of input data. The last dimension represents each data sample.</li><li><code>z::AbstractMatrix</code>: Matrix of corresponding latent representations of the input data.</li><li><code>z_shuffle::AbstractMatrix</code>: Matrix of latent representations where the second dimension has been shuffled.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: An approximation of the mutual information between the input data and its corresponding latent representation.</li></ul><p><strong>References</strong></p><blockquote><p>Rezaabad, A. L. &amp; Vishwanath, S. Learning Representations by Maximizing Mutual Information in Variational Autoencoders. Preprint at http://arxiv.org/abs/1912.13361 (2020).</p></blockquote></div></section><section><div><pre><code class="language-julia hljs">variational_mutual_info(infomaxvae, x, z, z_shuffle)</code></pre><p>Compute a variational approximation of the mutual information between the input <code>x</code> and the latent code <code>z</code> using an <code>InfoMaxVAE</code> instance. Note that this estimate requires shuffling the latent codes between data samples. Therefore, it only applies to batch data cases. A single sample will not provide a meaningful estimate.</p><p><strong>Arguments</strong></p><ul><li><code>infomaxvae::InfoMaxVAE</code>: An InfoMaxVAE instance used to estimate mutual information.</li><li><code>x::AbstractArray</code>: Array of input data. The last dimension represents each data sample.</li><li><code>z::AbstractMatrix</code>: Matrix of corresponding latent representations of the input data.</li><li><code>z_shuffle::AbstractMatrix</code>: Matrix of latent representations where the second dimension has been shuffled.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: An approximation of the mutual information between the input data and its corresponding latent representation.</li></ul><p><strong>References</strong></p><blockquote><p>Rezaabad, A. L. &amp; Vishwanath, S. Learning Representations by Maximizing Mutual Information in Variational Autoencoders. Preprint at http://arxiv.org/abs/1912.13361 (2020).</p></blockquote></div></section><section><div><pre><code class="language-julia hljs">variational_mutual_info(
    infomaxvae::InfoMaxVAE,
    x::AbstractArray;
    seed::Union{Nothing,Int}=nothing
)</code></pre><p>Compute a variational approximation of the mutual information between the input <code>x</code> and the latent code <code>z</code> using an <code>InfoMaxVAE</code> instance. This function also shuffles the latent codes between data samples to provide a meaningful estimate even for a single data sample.</p><p><strong>Arguments</strong></p><ul><li><code>infomaxvae::InfoMaxVAE</code>: An InfoMaxVAE instance used to estimate mutual information.</li><li><code>x::AbstractArray</code>: Array of input data. The last dimension represents each data sample.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>seed::Union{Nothing,Int}</code>: Optional argument. The seed for the random number generator used for shuffling the latent codes. If not provided, a random seed will be used.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: An approximation of the mutual information between the input data and its corresponding latent representation.</li></ul><p><strong>References</strong></p><blockquote><p>Rezaabad, A. L. &amp; Vishwanath, S. Learning Representations by Maximizing Mutual Information in Variational Autoencoders. Preprint at http://arxiv.org/abs/1912.13361 (2020).</p></blockquote></div></section></article><h2 id="Default-initializations"><a class="docs-heading-anchor" href="#Default-initializations">Default initializations</a><a id="Default-initializations-1"></a><a class="docs-heading-anchor-permalink" href="#Default-initializations" title="Permalink"></a></h2><p><code>AutoEncoderToolkit.jl</code> provides default initializations for the <code>MutualInfoChain</code>. Although it gives the user less flexibility, it can be useful for quick prototyping.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain-Tuple{Union{Int64, Vector{&lt;:Int64}}, Int64, Vector{&lt;:Int64}, Vector{&lt;:Function}, Function}" href="#AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain-Tuple{Union{Int64, Vector{&lt;:Int64}}, Int64, Vector{&lt;:Int64}, Vector{&lt;:Function}, Function}"><code>AutoEncoderToolkit.InfoMaxVAEs.MutualInfoChain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MutualInfoChain(
    size_input::Union{Int,Vector{&lt;:Int}},
    n_latent::Int,
    mlp_neurons::Vector{&lt;:Int},
    mlp_activations::Vector{&lt;:Function},
    output_activation::Function;
    init::Function = Flux.glorot_uniform
)</code></pre><p>Constructs a default <code>MutualInfoChain</code>. </p><p><strong>Arguments</strong></p><ul><li><code>n_input::Int</code>: Number of input features to the <code>MutualInfoChain</code>.</li><li><code>n_latent::Int</code>: The dimensionality of the latent space.</li><li><code>mlp_neurons::Vector{&lt;:Int}</code>: A vector of integers where each element represents the number of neurons in the corresponding hidden layer of the MLP.</li><li><code>mlp_activations::Vector{&lt;:Function}</code>: A vector of activation functions to be used in the hidden layers. Length must match that of <code>mlp_neurons</code>.</li><li><code>output_activation::Function</code>: Activation function for the output neuron of the MLP.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>init::Function</code>: Initialization function for the weights of all layers in the <code>MutualInfoChain</code>. Defaults to <code>Flux.glorot_uniform</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MutualInfoChain</code>: A <code>MutualInfoChain</code> instance with the specified MLP architecture.</li></ul><p><strong>Notes</strong></p><p>The function will throw an error if the number of provided activation functions does not match the number of layers specified in mlp_neurons.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mmdvae/">« MMD-VAE (InfoVAE)</a><a class="docs-footer-nextpage" href="../hvae/">HVAE »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 13 May 2024 13:52">Monday 13 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
